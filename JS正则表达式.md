[TOC]

## 什么是正则表达式

> 正则是匹配模式，要么匹配字符，要么匹配位置



## 正则表达式结构

**`/`** **表达式式** `**/修饰符号`**



#### 使用

```js
	正则表达式.test(某字符串) //返回 Boolean true false
		

	某字符串.match(正则表达式) //返回匹配的结果 Array []
	var regex = /\d{2,5}/g;
  var string = "123 1234 12345 123456";
  console.log( string.match(regex) );
  // => ["123", "1234", "12345", "12345"]
```



## 正则表达式字符匹配攻略



#### 横向模糊匹配

```js
{m,n} //表示连续出现最少 m 次，最多 n 次。

/ab{2,5}c/ :第一个字符是 "a"，接下来是 2 到 5 个字符 "b"，最后是字符 "c"
也就是 abbc abbbc abbbbc abbbbbc 都符合
```



#### 纵向模糊匹配

```js
[abc] //表示该字符是可以字符 "a"、"b"、"c" 中的任何一个

/a[123]b/ 可以匹配如下三种字符串: "a1b"、"a2b"、"a3b"。

```



#### 字符组

```js
[abc] //表示匹配一个字符，它可以是 "a"、"b"、"c" 之一。
[1-6a-fG-M] // 等同于  [123456abcdefGHIJKLM]

字符串 "a"、"-"、"z" 包含连字符 -
写法：[-az] 或 [az-] 或 [a\-z] //即要么放在开头，要么放在结尾，要么转义。总之不会让引擎认为是范围表示法就行了。

```



#### 排除字符组

```js
^  //shift+6 表示取反
[^abc] //表示是一个除 "a"、"b"、"c"之外的任意一个字
  
```



#### 常见的简写形式

```js
\d  //表示 [0-9]。表示是一位数字。 记忆方式:其英文是 digit(数字)。
\D  //表示 [^0-9]。表示除数字外的任意字符

\w  //表示 [0-9a-zA-Z_]。表示数字、大小写字母和下划线。 记忆方式:w 是 word 的简写，也称单词字符。
\W  //表示 [^0-9a-zA-Z_]。非单词字符。

\s  //表示 [ \t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页 符。
		//记忆方式:s 是 space 的首字母，空白符的单词是 white space。
\S  //表示 [^ \t\v\n\r\f]。 非空白符。

. 一个点
//表示 [^\n\r\u2028\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符 除外。
//记忆方式:想想省略号 ... 中的每个点，都可以理解成占位符，表示任何类似的东西。

如果要匹配任意字符怎么办?可以使用 [\d\D]、[\w\W]、[\s\S] 和 [^] 中任何的一个。
```

![image-20190426235521199](/Users/wangjian/Library/Application Support/typora-user-images/image-20190426235521199.png)



#### 量词(量词也称重复)

```js
{m,} //表示至少出现 m 次
{m}  //等价于 {m,m}，表示出现 m 次
 ?   //等价于 {0,1}，表示出现或者不出现。 记忆方式:问号的意思表示，有吗?
 +   //等价于 {1,}，表示出现至少一次。 记忆方式:加号是追加的意思，得先有一个，然后才考虑追加
 *   //等价于 {0,}，表示出现任意次，有可能不出现。 记忆方式:看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来
```

![image-20190426235849686](/Users/wangjian/Library/Application Support/typora-user-images/image-20190426235849686.png)



#### 贪婪匹配与惰性匹配

##### 尽可能多的匹配 VS 尽可能少的匹配

>  贪婪匹配：匹配出最多的结果

```js
	var regex = /\d{2,5}/g;
  var string = "123 1234 12345 123456";
  console.log( string.match(regex) );
  // => ["123", "1234", "12345", "12345"]
其中正则 /\d{2,5}/，表示数字连续出现 2 到 5 次。会匹配 2 位、3 位、4 位、5 位连续数字。
但是其是贪婪的，它会尽可能多的匹配。你能给我 6 个，我就要 5 个。你能给我 3 个，我就要 3 个。
反正只要在能力范围内，越多越好。
```
我们知道有时贪婪不是一件好事(请看文章最后一个例子)


> 惰性匹配：尽可能少的匹

```js
	var regex = /\d{2,5}?/g;
  var string = "123 1234 12345 123456";
  console.log( string.match(regex) );
  // => ["12", "12", "34", "12", "34", "12", "34", "56"]
/\d{2,5}?/ 表示，虽然 2 到 5 次都行，当 2 个就够的时候，就不再往下尝试了。
```

通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下:

| 惰性量词 | 贪婪量词 |
| -------- | -------- |
| {m,n}?   | {m,n}    |
| {m,}?    | {m,}     |
| ??       | ?        |
| +?       | +        |
| *?       | *        |

> 对惰性匹配的记忆方式是:量词后面加个问号，问一问你知足了吗，你很贪婪吗?

![image-20190427001039159](/Users/wangjian/Library/Application Support/typora-user-images/image-20190427001039159.png)





#### 多选分支

>  格式： (多选分之表达式)   小括号把表达式括起来

一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一

```js
具体形式如下:(p1|p2|p3)，其中 p1、p2 和 p3 是子模式，用 |(管道符)分隔，表示其中任何之一。
例如要匹配字符串 "good" 和 "nice" 可以使用 /good|nice/。
```

> 但是多选分之是惰性的，即当前面的匹配上了，后面的就不再尝试了。 

例如：
```js
	var regex = /good|goodbye/g;
  var string = "goodbye";
  console.log( string.match(regex) );
  // => ["good"] 匹配到一个就不会再匹配了
```



#### 案例分析

##### 16进制颜色匹配

```js
  var regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;
  var string = "#ffbbad #Fc01DF #FFF #ffE";
  console.log( string.match(regex) );
  // => ["#ffbbad", "#Fc01DF", "#FFF", "#ffE"]
```

##### 匹配时间

以 24 小时制为例。

要求匹配:

```js
23:59
02:07
```

分析:
共 4 位数字，第一位数字可以为 [0-2]。
当第 1 位为 "2" 时，第 2 位可以为 [0-3]，其他情况时，第 2 位为 [0-9]。
第 3 位数字为 [0-5]，第4位为 [0-9]。

```js
  var regex = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/;
  console.log( regex.test("23:59") );
  console.log( regex.test("02:07") );
  // => true
  // => true
```

 正则中使用了 ^ 和 $，分别表示字符串开头和结尾

如果也要求匹配 "7:9"，也就是说时分前面的 "0" 可以省略。

```js
	var regex = /^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/;
  console.log( regex.test("23:59") );
  console.log( regex.test("02:07") );
  console.log( regex.test("7:9") );
  // => true
  // => true
  // => true
```



##### 匹配日期

比如 yyyy-mm-dd 格式为例。

要求匹配

```js
2017-06-10
```

分析:
年，四位数字即可，可用 [0-9]{4}。
月，共 12 个月，分两种情况 "01"、"02"、...、"09" 和 "10"、"11"、"12"，可用 (0[1-9]|1[0-2])。
日，最大 31 天，可用 (0[1-9]|[12][0-9]|3[01])。

```js
  var regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;
  console.log( regex.test("2017-06-10") );
  // => true
```

##### **window** 操作系统文件路径 盘符\

```js
  F:\study\javascript\regex\regular expression.pdf
  F:\study\javascript\regex\
  F:\study\javascript
  F:\
```

盘符:\文件夹\文件夹\文件夹\

其中匹配 "F:\"，需要使用 [a-zA-Z]:\\，其中盘符不区分大小写，注意 \ 字符需要转义。 

文件名或者文件夹名，不能包含一些特殊字符，此时我们需要排除字符组 [^\\:*<>|"?\r\n/] 来表示合法 字符。 

另外它们的名字不能为空名，至少有一个字符，也就是要使用量词 +。因此匹配 文件夹\，可用 [^\\:*<>|"?\r\n/]+\\。 

另外 文件夹\，可以出现任意次。也就是 ([^\\:*<>|"?\r\n/]+\\)*。其中括号表示其内部正则是一个整 路径的最后一部分可以是 文件夹，没有 \，因此需要添加 ([^\\:*<>|"?\r\n/]+)?。
最后拼接成了一个看起来比较复杂的正则

```js

  var regex = /^[a-zA-Z]:\\([^\\:*<>|"?\r\n/]+\\)*([^\\:*<>|"?\r\n/]+)?$/;
  console.log( regex.test("F:\\study\\javascript\\regex\\regular expression.pdf") );
  console.log( regex.test("F:\\study\\javascript\\regex\\") );
  console.log( regex.test("F:\\study\\javascript") );
  console.log( regex.test("F:\\") );
  // => true
  // => true
  // => true
  // => true
```

##### 匹配 **id**

```html
<div id="container" class="main"></div>
```

可能最开始想到的正则是: 

```js
  var regex = /id=".*"/
  var string = '<div id="container" class="main"></div>';
  console.log(string.match(regex)[0]);
  // => id="container" class="main"
```

因为 . 是通配符，本身就匹配双引号的，而量词 * 又是贪婪的，当遇到 container 后面双引号时，是不会 停下来，会继续匹配，直到遇到最后一个双引号为止。 

解决之道，可以使用惰性匹配: 

```js
  var regex = /id=".*?"/
  var string = '<div id="container" class="main"></div>';
  console.log(string.match(regex)[0]);
  // => id="container"
```





## 正则表达式位置匹配攻略

> 正则表达式是匹配模式，要么匹配字符，要么匹配位置

### 什么是位置呢?

位置(锚)是相邻字符之间的位置。比如，下图中箭头所指的地方:

![image-20190427004540527](/Users/wangjian/Library/Application Support/typora-user-images/image-20190427004540527.png)

### 如何匹配位置呢?

在 ES5 中，共有 6 个锚: 

```js
^、$、\b、\B、(?=p)、(?!p) 
```

![image-20190427004633736](/Users/wangjian/Library/Application Support/typora-user-images/image-20190427004633736.png)

#### **^** 和 **$**

^(脱字符)匹配开头，在多行匹配中匹配行开头。 

$(美元符号)匹配结尾，在多行匹配中匹配行结尾。 

```js
  var result = "hello".replace(/^|$/g, '#');
  console.log(result);
  // => "#hello#"
```



也就是

> ^ 匹配的是第一个字符之前的空白位置

> $ 匹配的是最后一个字符之后的空白位置



















